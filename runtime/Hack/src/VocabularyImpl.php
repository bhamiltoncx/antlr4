<?hh // strict

/*
 * Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

namespace ANTLR;

/**
 * This class provides a default implementation of the {@link Vocabulary}
 * interface.
 */
class VocabularyImpl implements Vocabulary {
  private static array<string> $EMPTY_NAMES = array();

  /**
   * Gets an empty {@link Vocabulary} instance.
   *
   * <p>
   * No literal or symbol names are assigned to token types, so
   * {@link #getDisplayName(int)} returns the numeric value for all tokens
   * except {@link Token#EOF}.</p>
   */
  public static VocabularyImpl $EMPTY_VOCABULARY = new VocabularyImpl($EMPTY_NAMES, $EMPTY_NAMES,$ EMPTY_NAMES);


  private array<?string> $literalNames;

  private array<?string> $symbolicNames;

  private array<?string> $displayNames;

  private int $maxTokenType;

  /**
   * Constructs a new instance of {@link VocabularyImpl} from the specified
   * literal, symbolic, and display token names.
   *
   * @param literalNames The literal names assigned to tokens, or {@code null}
   * if no literal names are assigned.
   * @param symbolicNames The symbolic names assigned to tokens, or
   * {@code null} if no symbolic names are assigned.
   * @param displayNames The display names assigned to tokens, or {@code null}
   * to use the values in {@code literalNames} and {@code symbolicNames} as
   * the source of display names, as described in
   * {@link #getDisplayName(int)}.
   *
   * @see #getLiteralName(int)
   * @see #getSymbolicName(int)
   * @see #getDisplayName(int)
   */
  public function __construct(
    array<?string> $literalNames,
    array<?string> $symbolicNames,
    array<?string> $displayNames = array(),
  ) {
    $this->literalNames = $literalNames;
    $this->symbolicNames = $symbolicNames;
    $this->displayNames = $displayNames;
    // See note here on -1 part: https://github.com/antlr/antlr4/pull/1146
    $this->maxTokenType = C\max(
      count($this->literalNames),
      count($this->displayNames),
      count($this->displayNames),
    ) - 1;
  }

  /**
   * Returns a {@link VocabularyImpl} instance from the specified set of token
   * names. This method acts as a compatibility layer for the single
   * {@code tokenNames} array generated by previous releases of ANTLR.
   *
   * <p>The resulting vocabulary instance returns {@code null} for
   * {@link #getLiteralName(int)} and {@link #getSymbolicName(int)}, and the
   * value from {@code tokenNames} for the display names.</p>
   *
   * @param tokenNames The token names, or {@code null} if no token names are
   * available.
   * @return A {@link Vocabulary} instance which uses {@code tokenNames} for
   * the display names of tokens.
   */
  public static function fromTokenNames(array<?string> $tokenNames): Vocabulary {
    if (count($tokenNames) == 0) {
      return static::$EMPTY_VOCABULARY;
    }

    $literalNames = $tokenNames;
    $symbolicNames  $tokenNames;

    for ($i = 0; i < count($tokenNames); $i++) {
      $tokenName = $tokenNames[i];
      if ($tokenName === null) {
        continue;
      }

      if ($tokenName !== '') {
        $firstChar = fb_utf8_substr($tokenName, 0, 1);
        if ($firstChar == "'") {
          $symbolicNames[$i] = null;
          continue;
        }
        elseif (IntlChar::isUpper($firstChar)) {
          $literalNames[$i] = null;
          continue;
        }
      }

      // wasn't a literal or symbolic name
      $literalNames[$i] = null;
      $symbolicNames[$i] = null;
    }

    return new VocabularyImpl($literalNames, $symbolicNames, $tokenNames);
  }

  <<__Override>>
  public function getMaxTokenType(): int {
    return $this->maxTokenType;
  }

  <<__Override>>
  public function getLiteralName(int $tokenType): ?string {
    return HH\idx($this->literalNames, $tokenType);
  }

  <<__Override>>
  public function getSymbolicName(int $tokenType): ?string {
    if ($tokenType == Token::EOF) {
      return 'EOF';
    }
    else {
      return HH\idx($this->symbolicNames, $tokenType);
    }
  }

  <<__Override>>
  public function getDisplayName(int $tokenType): string {
    return
      $this->getDisplayName($tokenType) ??
      $this->getLiteralName($tokenType) ??
      $this->getSymbolicName($tokenType) ??
      (string)$tokenType;
  }
}
