/*
 * [The "BSD license"]
 *  Copyright (c) 2012-2016 Terence Parr
 *  Copyright (c) 2012-2016 Sam Harwell
 *  Copyright (c) 2015 Janyou
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

HackTypeInitMap ::= [
	"int":"0",
	"float":"0.0",
	"bool":"false",
	default:"null" // anything other than a primitive type is an object
]

HackTypeMap ::= [
	"byte":"int",
	"short":"int",
	"char":"int",
	"long":"int",
	"double":"float",
	"boolean":"bool",
	default : key
]
// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, namedActions,contextSuperClass) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>
<namedActions.header>

<parser>
>>

ListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>
<header>

/**
 * This interface defines a complete listener for a parse tree produced by
 * {@link <file.parserName>}.
 */
interface <file.grammarName>Listener: ParseTreeListener {
	<file.listenerNames:{lname |
  /**
  <if(file.listenerLabelRuleNames.(lname))>
   * Enter a parse tree produced by the {@code <lname>\}
   * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
  <else>
   * Enter a parse tree produced by {@link <file.parserName>#<lname>\}.
  <endif>
   - Parameters:
     - $ctx: the parse tree
   */
  public function enter<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): void;
  /**
  <if(file.listenerLabelRuleNames.(lname))>
   * Exit a parse tree produced by the {@code <lname>\}
   * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
  <else>
   * Exit a parse tree produced by {@link <file.parserName>#<lname>\}.
  <endif>
   - Parameters:
     - $ctx: the parse tree
   */
  public function exit<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): void;
}; separator="\n">
\}
>>

BaseListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>
<header>


/**
 * This trait provides a default implementation of {@link <file.grammarName>Listener},
 * which can be overridden to create a listener which only needs to handle a subset
 * of the available methods.
 */
trait <file.grammarName>ListenerTrait {
  require implements <file.grammarName>Listener;
	<file.listenerNames:{lname |

/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation does nothing.\</p>
 */
  public function enter<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): void { \}
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation does nothing.\</p>
 */
  public function exit<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): void { \}
}; separator="\n">

	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	public function enterEveryRule(ParserRuleContext $ctx): void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	public function exitEveryRule(ParserRuleContext $ctx): void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	public function visitTerminal(TerminalNode $node): void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	public function visitErrorNode(ErrorNode $node): void { }
}
>>

VisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>
<header>

/**
 * This interface defines a complete generic visitor for a parse tree produced
 * by {@link <file.parserName>}.
 *
 * @param \<T> The return type of the visit operation. Use {@link void} for
 * operations with no return type.
 */
public abstract class <file.grammarName>Visitor\<T> implements ParseTreeVisitor\<T> {
	<file.visitorNames:{lname |
/**
<if(file.visitorLabelRuleNames.(lname))>
 * Visit a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.visitorLabelRuleNames.(lname)>\}.
<else>
 * Visit a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
- Parameters:
  - $ctx: the parse tree
- returns: the visitor result
 */
public abstract function visit<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): T;
}; separator="\n">
\}
>>

BaseVisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>
<header>

/**
 * This class provides an empty implementation of {@link <file.grammarName>Visitor},
 * which can be extended to create a visitor which only needs to handle a subset
 * of the available methods.
 *
 * @param \<T> The return type of the visit operation. Use {@link void} for
 * operations with no return type.
 */
class <file.grammarName>BaseVisitor\<T> extends AbstractParseTreeVisitor\<T> {
	<file.visitorNames:{lname |
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation returns the result of calling
 * {@link #visitChildren\} on {@code $ctx\}.\</p>
 */
public function visit<lname; format="cap">(<file.parserName><lname; format="cap">Context $ctx): ?T { return visitChildren($ctx) \}}; separator="\n">
}
>>

fileHeader(grammarFileName, ANTLRVersion) ::= <<
<?hh // strict

// Generated from <grammarFileName> by ANTLR <ANTLRVersion>

use ANTLR\\ATNDeserializer;
use ANTLR\\DFA;
use ANTLR\\ErrorNode;
use ANTLR\\NoViableAltException;
use ANTLR\\Parser;
use ANTLR\\ParserRuleContext;
use ANTLR\\PredictionContextCache;
use ANTLR\\RecognitionException;
use ANTLR\\RuntimeMetaData;
use ANTLR\\TerminalNode;
use ANTLR\\Token;
use ANTLR\\Vocabulary;

>>

Parser(parser, funcs, atn, sempredFuncs, superClass) ::= <<
<Parser_(ctor="parser_ctor", ...)>
>>

Parser_(parser, funcs, atn, sempredFuncs, ctor, superClass) ::= <<
class <parser.name> extends <superClass; null="Parser"> {

	private static vec<DFA> $decisionToDFA = vec[];
	private static bool $decisionToDFAInitialized = false;
	private static function getDecisionToDFA(): vec<DFA> {
		if (static::$decisionToDFAInitialized) {
		   return static::$decisionToDFA;
		}
		static::$decisionToDFAInitialized = true;
		$length = static::$ATN-\>getNumberOfDecisions();
		for ($i = 0; $i < $length; $i++) {
		    static::$decisionToDFA[] = new DFA(nullthrows(static::$ATN-\>getDecisionState(i)), $i);
		}
		return static::$decisionToDFA;
	}
	private static PredictionContextCache $sharedContextCache = new PredictionContextCache();
	<if(parser.tokens)>
	<parser.tokens:{k | public static int <k> = <parser.tokens.(k)>;
	}; separator="\n">
	}
        <endif>
        <parser.rules:{r | public static int RULE_<r.name> = <r.index>;
	}; separator="\n">
	public static vec<string> $ruleNames = vec[
		<parser.ruleNames:{r | '<r>'}; separator=", ", wrap, anchor>
	];

	<vocabulary(parser.literalNames, parser.symbolicNames)>

	<<__Override>>
	public function getGrammarFileName(): string { return "<parser.grammarFileName>"; }

	<<__Override>>
	public function getRuleNames(): vec<string> { return static::$ruleNames; }

	<<__Override>>
	public function getSerializedATN(): string { return static::$SERIALIZED_ATN; }

	<<__Override>>
	public function getATN(): ATN { return static::$ATN; }

	<namedActions.members>
	<parser:(ctor)()>
	<funcs; separator="\n">

<if(sempredFuncs)>
    <<__Override>>
	public function sempred(RuleContext? $localctx, int $ruleIndex,  int $predIndex): bool {
		switch (ruleIndex) {
			<parser.sempredFuncs.values:{f|
			case <f.ruleIndex>:
				return <f.name>_sempred((<f.ctxType>?)$localctx), $predIndex)}; separator="\n"
			>
			default:
				return true;
		}
	}
	<sempredFuncs.values; separator="\n">
<endif>

	<atn>
	public static ATN $ATN = ATNDeserializer::deserialize(SERIALIZED_ATN);
}
>>

vocabulary(literalNames, symbolicNames) ::= <<
private static vec<string> $LITERAL_NAMES = vec[
	<literalNames:{t | <t>}; separator=", ", wrap, anchor>
];
private static vec<string> $SYMBOLIC_NAMES = vec[
	<symbolicNames:{t | <t>}; separator=", ", wrap, anchor>
];
public static Vocabulary $VOCABULARY = new Vocabulary(static::$LITERAL_NAMES, static::$SYMBOLIC_NAMES);
>>

dumpActions(recog, argFuncs, actionFuncs, sempredFuncs) ::= <<
<if(actionFuncs)>
<<__Override>>
public function action(?RuleContext $localctx, int $ruleIndex, int $actionIndex): void {
	switch ($ruleIndex) {
	<recog.actionFuncs.values:{f|
		case <f.ruleIndex>:
			<f.name>_action((<f.ctxType>?)$localctx, $actionIndex);
			break;
        }; separator="\n">
	}
}
<actionFuncs.values; separator="\n">
<endif>
<if(sempredFuncs)>
<<__Override>>
public function sempred(?RuleContext $localctx, int $ruleIndex, int $predIndex): bool {
	switch ($ruleIndex) {
	<recog.sempredFuncs.values:{f|
		case <f.ruleIndex>:
			return <f.name>_sempred((?<f.ctxType>)$localctx, $predIndex);
	}; separator="\n">
		default:
			return true;
	}
}
<sempredFuncs.values; separator="\n">
<endif>
>>

parser_ctor(p) ::= <<

<<__Override>
public function __construct(TokenStream $input) {
       parent::__construct($input);
       RuntimeMetaData::checkVersion("4.7", RuntimeMetaData::VERSION)
       $this-\>interp = new ParserATNSimulator($this, static::$ATN, static::$decisionToDFA, static::$sharedContextCache)
}
>>

/* This generates a private method since the actionIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleActionFunction(r, actions) ::= <<
private function <r.name>_action(<r.ctxType>? $localctx, int $actionIndex): void {
	switch ($actionIndex) {
	<actions:{index|
		case <index>:
			<actions.(index)>
			break;
	}; separator="\n">
	}
}
>>

/* This generates a private method since the predIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleSempredFunction(r, actions) ::= <<
private function <r.name>_sempred(<r.ctxType> $localctx, int $predIndex): bool {
	switch (predIndex) {
	<actions:{index|
		case <index>:
			return <actions.(index)>;
	}; separator="\n">
		default:
			return true;
	}
}
>>

RuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,namedActions,finallyAction,postamble,exceptions) ::= <<
<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">
<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>public final <endif> function <currentRule.name>(<args; separator=", ">): <currentRule.ctxType> {
	<currentRule.ctxType> $localctx = new <currentRule.ctxType>($this-\>ctx, getState()<currentRule.args:{a | , <a.name>}>);
	$this-\>enterRule($localctx, <currentRule.startState>, static::$RULE_<currentRule.name>);
	<namedActions.init>
	<locals; separator="\n">
	try {
<if(currentRule.hasLookaheadBlock)>
		$alt = -1;
<endif>
		<code>
		<postamble; separator="\n">
		<namedActions.after>
	}
	<if(exceptions)>
	<exceptions; separator="\n">
	<else>
	catch (RecognitionException $re) {
		$localctx-\>exception = $re;
		$this-\>errHandler-\>reportError($this, $re);
		$this-\>errHandler-\>recover($this, $re);
	}
	<endif>
	finally {
		<finallyAction>
		$this-\>exitRule();
	}

	return $localctx;
}
>>

LeftRecursiveRuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,
	namedActions,finallyAction,postamble) ::=
<<

<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">

<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>public final <endif> function <currentRule.name>(<args; separator=", ">): <currentRule.ctxType> {
	return $this-\><currentRule.name>(0<currentRule.args:{a | , <a.name>}>);
}
private function <currentRule.name>(int $p<args:{a | , <a>}>): <currentRule.ctxType> {
	$parentctx = $this-\>ctx;
	$parentState = $this-\>getState();
	$localctx = new <currentRule.ctxType>($this-\>ctx, $parentState<currentRule.args:{a | , <a.name>}>);
	$prevctx = $localctx;
	$startState = <currentRule.startState>;
	$this-\>enterRecursionRule($localctx, <currentRule.startState>, static::RULE_<currentRule.name>, $p);
	<namedActions.init>
	<locals; separator="\n">
	try {
<if(currentRule.hasLookaheadBlock)>
		$alt = -1;
<endif>
		<code>
		<postamble; separator="\n">
		<namedActions.after>
	}
	catch (RecognitionException $re) {
		$localctx-\>exception = $re;
		$this-\>errHandler-\>reportError($this, $re);
		$this-\>errHandler-\>recover($this, $re);
	}
	finally {
		<finallyAction>
		$this-\>unrollRecursionContexts($parentctx);
	}

	return $localctx;
}
>>

CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if(currentOuterMostAltCodeBlock.altLabel)>$localctx = new <currentOuterMostAltCodeBlock.altLabel; format="cap">Context($localctx);<endif>
$this-\>enterOuterAlt($localctx, <currentOuterMostAltCodeBlock.alt.altNum>);
<CodeBlockForAlt(currentAltCodeBlock=currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
{
<locals; separator="\n">
<preamble; separator="\n">
<ops; separator="\n">
}
>>

LL1AltBlock(choice, preamble, alts, error) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
<if(choice.label)>$<labelref(choice.label)> = $this-\>input-\>LT(1);<endif>
<preamble; separator="\n">
switch ($this-\>input-\>LA(1)) {
<choice.altLook,alts:{look,alt | <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
default:
	<error>
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
switch ($this-\>input-\>LA(1)) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
}
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
<preamble; separator="\n">
if (<expr>) {
	<alts; separator="\n">
}
<!else if ( !(<followExpr>) ) <error>!>
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
<preamble; separator="\n">
while (<loopExpr>) {
	<alts; separator="\n">
	$this-\>setState(<choice.loopBackStateNumber>);
	$this-\>errHandler-\>sync($this);
	<iteration>
}
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
$this-\>setState(<choice.blockStartStateNumber>); <! alt block decision !>
$this-\>errHandler-\>sync($this);
<preamble; separator="\n">
do {
	<alts; separator="\n">
	$this-\>setState(<choice.stateNumber>); <! loopback/exit decision !>
	$this-\>errHandler-\>sync($this);
	<iteration>
} while (<loopExpr>);
>>

// LL(*) stuff

AltBlock(choice, preamble, alts, error) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
<if(choice.label)>$<labelref(choice.label)> = $this-\>input-\>LT(1);<endif>
<preamble; separator="\n">
switch ($this-\>getInterpreter()-\>adaptivePredict($this-\>input, <choice.decision>, $this-\>ctx)) {
<alts:{alt |
case <i>:
	<alt>
	break;}; separator="\n">
}
>>

OptionalBlock(choice, alts, error) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
switch ($this-\>getInterpreter()-\>adaptivePredict($this-\>input, <choice.decision>, $this-\>ctx)) {
<alts:{alt |
case <i><if(!choice.ast.greedy)>+1<endif>:
	<alt>
	break;}; separator="\n">
}
>>

StarBlock(choice, alts, sync, iteration) ::= <<
$this-\>setState(<choice.stateNumber>);
$this-\>errHandler-\>sync($this);
$alt = $this-\>getInterpreter()-\>adaptivePredict($this-\>input, <choice.decision>, $this-\>ctx);
while ($alt != <choice.exitAlt> && $alt != ATN::INVALID_ALT_NUMBER) {
	if ( $alt==1<if(!choice.ast.greedy)>+1<endif> ) {
		<iteration>
		<alts> <! should only be one !>
	}
	$this-\>setState(<choice.loopBackStateNumber>);
	$this-\>errHandler-\>sync($this);
	$alt = $this-\>getInterpreter()-\>adaptivePredict($this-\>input, <choice.decision>, $this-\>ctx);
}
>>

PlusBlock(choice, alts, error) ::= <<
$this-\>setState(<choice.blockStartStateNumber>); <! alt block decision !>
$this-\>errHandler-\>sync($this);
$alt = 1<if(!choice.ast.greedy)>+1<endif>;
do {
	switch ($alt) {
	<alts:{alt|
		case <i><if(!choice.ast.greedy)>+1<endif>:
			<alt>
			break;
	}; separator="\n">
		default:
			<error>
	}
	$this-\>setState(<choice.loopBackStateNumber>); <! loopback/exit decision !>
	$this-\>errHandler-\>sync($this);
	_alt = $this-\>getInterpreter()-\>adaptivePredict($this-\>input, <choice.decision>, $this-\>ctx);
} while ($alt != <choice.exitAlt> && $alt != ATN::INVALID_ALT_NUMBER);
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAlt(t) ::= "throw new NoViableAltException($this);"

TestSetInline(s) ::= <<
<s.bitsets:{bits | <if(rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount>) & ~0x3f) == 0
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <%
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> && ((1L \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes:{ttype | (1L \<\< <offsetShift(ttype, bits.shift)>)}; separator=" | ">)) != 0)
%>

isZero ::= [
"0":true,
default:false
]

offsetShift(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>(<shiftAmount> - <offset>)<else><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
%>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRule(r, argExprsChunks) ::= <<
$this-\>setState(<r.stateNumber>);
<if(r.labels)><r.labels:{l | <labelref(l)> = }><endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>);
>>

MatchToken(m) ::= <<
$this-\>setState(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }><endif>match(<m.name>);
>>

MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
$this-\>setState(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }>$this-\>input-\>LT(1);<endif>
<capture>
if ( <if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>) ) {
	<if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>$this-\>errHandler-\>recoverInline(this);
}
else {
	if ( $this-\>input-\>LA(1)==Token::EOF ) matchedEOF = true;
	$this-\>errHandler-\>reportMatch($this);
	$this-\>consume();
}
>>

Wildcard(w) ::= <<
$this-\>setState(<w.stateNumber>);
<if(w.labels)><w.labels:{l | <labelref(l)> = }><endif>matchWildcard();
>>

// ACTION STUFF

Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "<chunks>"

SemPred(p, chunks, failChunks) ::= <<
$this-\>setState(<p.stateNumber>);
if (!(<chunks>)) {
    throw new RecognitionException(e:FailedPredicateException($this, <p.predicate><if(failChunks)>, <failChunks><elseif(p.msg)>, <p.msg><endif>));
}
>>

ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
	<catchAction>
}
>>

// lexer actions are not associated with model objects

LexerSkipCommand()  ::= "$this-\>skip();"
LexerMoreCommand()  ::= "$this-\>more();"
LexerPopModeCommand() ::= "$this-\>popMode();"

LexerTypeCommand(arg)      ::= "$this-\>type = <arg>;"
LexerChannelCommand(arg)   ::= "$this-\>channel = <arg>;"
LexerModeCommand(arg)      ::= "$this-\>mode = <arg>;"
LexerPushModeCommand(arg)  ::= "$this-\>pushMode(<arg>);"

ActionText(t) ::= "<t.text>"
ActionTemplate(t) ::= "<t.st>"
ArgRef(a) ::= "$localctx-\><a.name>"
LocalRef(a) ::= "$localctx-\><a.name>"
RetValueRef(a) ::= "$localctx-\><a.name>"
QRetValueRef(a) ::= "<ctx(a)>-\><a.dict>-\><a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<ctx(t)>-\><t.name>"
LabelRef(t) ::= "<ctx(t)>-\><t.name>"
ListLabelRef(t) ::= "<ctx(t)>-\><ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "<ctx(s)>-\><s.name> = <rhsChunks>;"

TokenLabelType() ::= "<file.TokenLabelType; null={Token}>"
InputSymbolType() ::= "<file.InputSymbolType; null={Token}>"

TokenPropertyRef_text(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getText():null)"
TokenPropertyRef_type(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getType():0)"
TokenPropertyRef_line(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getLine():0)"
TokenPropertyRef_pos(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getChannel():0)"
TokenPropertyRef_index(t) ::= "(<ctx(t)>-\><t.label>!==null?<ctx(t)>-\><t.label>-\>getTokenIndex():0)"
TokenPropertyRef_int(t) ::= "(<ctx(t)>-\><t.label>!==null?Integer.valueOf(<ctx(t)>-\><t.label>-\>getText()):0)"

RulePropertyRef_start(r) ::= "(<ctx(r)>-\><r.label>!==null?(<ctx(r)>-\><r.label>-\>start):null)"
RulePropertyRef_stop(r)	 ::= "(<ctx(r)>-\><r.label>!==null?(<ctx(r)>-\><r.label>-\>stop):null)"
RulePropertyRef_text(r)	 ::= "(<ctx(r)>-\><r.label>!==null?$this-\>input-\>getText(<ctx(r)>-\><r.label>-\>start,<ctx(r)>-\><r.label>-\>stop):null)"
RulePropertyRef_ctx(r)	 ::= "<ctx(r)>-\><r.label>"
RulePropertyRef_parser(r)	 ::= "$this"

ThisRulePropertyRef_start(r) ::= "$localctx-\>start"
ThisRulePropertyRef_stop(r)	 ::= "$localctx-\>stop"
ThisRulePropertyRef_text(r)	 ::= "$input-\>getText($localctx-\>start, $this-\>input-\>LT(-1))"
ThisRulePropertyRef_ctx(r)	 ::= "$localctx"
ThisRulePropertyRef_parser(r)	 ::= "$this"

NonLocalAttrRef(s)		 ::= "((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>))-\><s.name>"
SetNonLocalAttr(s, rhsChunks)	  ::=
	"((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>))-\><s.name> = <rhsChunks>;"

AddToLabelList(a) ::= "<ctx(a.label)>-\><a.listName>-\>add(<labelref(a.label)>);"

TokenDecl(t) ::= "<TokenLabelType()> <t.name>"
TokenTypeDecl(t) ::= "int <t.name>;"
TokenListDecl(t) ::= "vec\<Token> <t.name> = vec[]"
RuleContextDecl(r) ::= "<r.ctxName> <r.name>"
RuleContextListDecl(rdecl) ::= "vec\<<rdecl.ctxName>> <rdecl.name> = vec[]"

ContextTokenGetterDecl(t)      ::=
    "public function <t.name>(): TerminalNode { return $this-\>getToken(static::<t.name>, 0); }"
ContextTokenListGetterDecl(t)  ::=
    "public function <t.name>(): vec<TerminalNode> { return $this-\>getTokens(static::<t.name>); }"
ContextTokenListIndexedGetterDecl(t)  ::= <<
public function <t.name>(int $i): TerminalNode {
	return $this-\>getToken(static::<t.name>, $i);
}
>>
ContextRuleGetterDecl(r)       ::= <<
public function <r.name>(): <r.ctxName> {
	return $this-\>getRuleContext(get_class(<r.ctxName>),0);
}
>>
ContextRuleListGetterDecl(r)   ::= <<
public function <r.name>(): vec\<<r.ctxName>\> {
	return $this-\>getRuleContexts(get_class(<r.ctxName>));
}
>>
ContextRuleListIndexedGetterDecl(r)   ::= <<
public function <r.name>(int $i): <r.ctxName> {
	return $this-\>getRuleContext(get_class(<r.ctxName>,$i);
}
>>

LexerRuleContext() ::= "RuleContext"

/** The rule context name is the rule followed by a suffix; e.g.,
 *	r becomes rContext.
 */
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= "$this-\><tokenName>"
ImplicitRuleLabel(ruleName)	  ::= "$this-\><ruleName>"
ImplicitSetLabel(id)		  ::= "$this-\>tset<id>"
ListLabelName(label)		  ::= "$this-\><label>"

CaptureNextToken(d) ::= "$this-\><d.varName> = $this-\>input-\>LT(1);"
CaptureNextTokenType(d) ::= "$this-\><d.varName> = $this-\>input-\>LA(1);"

StructDecl(struct,ctorAttrs,attrs,getters,dispatchMethods,interfaces,extensionMembers)
	::= <<
class <struct.name> extends <if(contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif><if(interfaces)> implements <interfaces; separator=", "><endif> {
	<attrs:{a | public <a>;}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	<if(ctorAttrs)>public function __construct(ParserRuleContext $parent, int $invokingState) { parent::__construct($parent, $invokingState); }<endif>
	public function __construct (ParserRuleContext $parent, int $invokingState<ctorAttrs:{a | , <a>}>) {
		parent::__construct($parent, $invokingState);
		<struct.ctorAttrs:{a | $this-\><a.name> = <a.name>;}; separator="\n">
	}
	<<__Override>>
	public function getRuleIndex(): int { return static::$RULE_<struct.derivedFromName>; }
<if(struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
	public function __construct() { }
	public function copyFrom(<struct.name> $ctx): void {
		parent::copyFrom($ctx);
		<struct.attrs:{a | $this-\><a.name> = ctx.<a.name>;}; separator="\n">
	}
<endif>
	<dispatchMethods; separator="\n">
	<extensionMembers; separator="\n">
}
>>

AltLabelStructDecl(struct,attrs,getters,dispatchMethods) ::= <<
public final class <struct.name> extends <currentRule.name; format="cap">Context {
	<attrs:{a | public <a>}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	public function __construct(<currentRule.name; format="cap">Context $ctx) {
		$this-\>copyFrom($ctx);
	}
	<dispatchMethods; separator="\n">
}
>>

ListenerDispatchMethod(method) ::= <<
<<__Override>>
public function <if(method.isEnter)>enter<else>exit<endif>Rule(ParseTreeListener $listener): void {
	if ( $listener instanceof <parser.grammarName>Listener ) {
		((<parser.grammarName>Listener) $listener)-\><if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">($this);
	}
}
>>

VisitorDispatchMethod(method) ::= <<
<<__Override>>
public function accept\<T>(visitor: ParseTreeVisitor\<T>): ?T {
	if ( $visitor instanceof <parser.grammarName>Visitor ) {
	     return ((<parser.grammarName>Visitor\<T>) $visitor)-\>visit<struct.derivedFromName; format="cap">($this);
	} elseif ( $visitor instanceof <parser.grammarName>BaseVisitor ) {
	     return ((<parser.grammarName>BaseVisitor\<T>) $visitor)-\>visit<struct.derivedFromName; format="cap">($this);
	} else {
	     return $visitor-\>visitChildren($this);
	}
}
>>

AttributeDecl(d) ::= "<HackTypeMap.(d.type)> <d.name><if(d.initValue)> = <d.initValue><endif>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if(!x.isLocal)>(<x.ctx.name>)$localctx-\><endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr?    */
ctx(actionChunk) ::= "((<actionChunk.ctx.name>)$localctx);"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec)  ::= "$this-\>precpred($this-\>ctx, <opPrec>);"
recRuleSetReturnAction(src,name)	  ::= "$<name>=$<src>-\><name>;"
recRuleSetStopToken()                 ::= "$this-\>ctx-\>stop = $this-\>input-\>LT(-1);"

recRuleAltStartAction(ruleName, ctxName, label, isListLabel) ::= <<
$localctx = new <ctxName>Context($parentctx, $parentState);
<if(label)>
<if(isListLabel)>
$localctx-\><label>-\>append($prevctx);
<else>
$localctx-\><label> = $prevctx;
<endif>
<endif>
<if(label)>$localctx-\><label> = $prevctx;<endif>
$this-\>pushNewRecursionContext($localctx, $startState, static::RULE_<ruleName>);
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= <<
$localctx = new <currentAltLabel; format="cap">Context(new <ruleName; format="cap">Context($parentctx, $parentState));
<if(label)>
<if(isListLabel)>
((<currentAltLabel; format="cap">Context)$localctx)-\><label>-\>add($prevctx);
<else>
((<currentAltLabel; format="cap">Context)$localctx)-\><label> = $prevctx;
<endif>
<endif>
pushNewRecursionContext($localctx, $startState, static::RULE_<ruleName>);
>>

recRuleReplaceContext(ctxName) ::= <<
$localctx = new <ctxName>Context($localctx);
$ctx = $localctx;
$prevctx = $localctx;
>>

recRuleSetPrevCtx() ::= <<
if ( $parseListeners!==null ) { $this-\>triggerExitRuleEvent(); }
$prevctx = $localctx;
>>


LexerFile(lexerFile, lexer, namedActions) ::= <<
<fileHeader(lexerFile.grammarFileName, lexerFile.ANTLRVersion)>
<if(lexerFile.genPackage)>
namespace <lexerFile.genPackage>;
<endif>
<namedActions.header>
use ANTLR\\Lexer;
use ANTLR\\CharStream;
use ANTLR\\Token;
use ANTLR\\TokenStream;
use ANTLR\\DFA;
use ANTLR\\ATN\\ATNDeserializer;
use ANTLR\\ATN\\PredictionContextCache;

<lexer>
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<
class <lexer.name> extends <superClass; null="Lexer"> {

	private static final vec<DFA> $decisionToDFA;
	private static final PredictionContextCache $sharedContextCache =
		new PredictionContextCache();
	<lexer.tokens:{k | public static final int $<k>=<lexer.tokens.(k)>;}; separator="\n">;
	<if(lexer.channels)>
	<lexer.channels:{c | public static final int $<c>=<lexer.channels.(c)>}; separator="\n">;
	<endif>
	<if(rest(lexer.modes))>
	<rest(lexer.modes):{m | public static final int $<m>=<i>}; separator="\n">;
	<endif>
	public static final vec<string> channelNames = vec[
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"<if (lexer.channels)>, <lexer.channels:{c| "<c>"}; separator=", ", wrap, anchor><endif>
	];

	public static final vec<string> modeNames = vec[
		<lexer.modes:{m| "<m>"}; separator=", ", wrap, anchor>
	];

	public static final vec<string> ruleNames = vec[
		<lexer.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
	];

	<vocabulary(lexer.literalNames, lexer.symbolicNames)>

	<namedActions.members>

	public function __construct(CharStream $input) {
		parent::__construct($input);
		RuntimeMetaData::checkVersion("4.7", RuntimeMetaData::VERSION)
		$this-\>interp = new LexerATNSimulator($this,static::$ATN,static::$decisionToDFA,static::$sharedContextCache);
	}

	<<__Override>>
	public string getGrammarFileName() { return "<lexer.grammarFileName>"; }

	<<__Override>>
	public vec<String> getRuleNames() { return static::$ruleNames; }

	<<__Override>>
	public string getSerializedATN() { return static::$serializedATN; }

	<<__Override>>
	public vec<string> getChannelNames() { return static::$channelNames; }

	<<__Override>>
	public vec<string> getModeNames() { return static::$modeNames; }

	<<__Override>>
	public ATN getATN() { return static::$ATN; }

	<dumpActions(lexer, "", actionFuncs, sempredFuncs)>
	<atn>
}
>>

SerializedATN(model) ::= <<
private static final string $SERIALIZED_ATN = "<model.serialized>";
public static final ATN $ATN = ATNDeserializer::deserialize(static::$SERIALIZED_ATN);
>>

/** Using a type to init value map, try to init a type; if not in table
 *	must be an object, default value is "null".
 */
initValue(typeName) ::= <<
 <HackTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".php"
